#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Allocator (modo sombra) ‚Äî SAFE PATCH (runner limpio) 2025-09-02

Cambios clave vs tu script previo:
- ‚ùå Elimino el bloque "debug" del encabezado que le√≠a CSVs viejos y mostraba NET D/P de un run anterior.
- ‚úÖ Muevo el c√°lculo/print de NET por pierna al FINAL del run, usando los datos en memoria del run actual.
- ‚úÖ Soporto `throttle` ya sea en `risk.throttle` o al nivel ra√≠z del YAML (robustez).
- ‚úÖ Clip de piso de volatilidad s√≥lo si `vol_floor_ann` no es None (evita errores).
- üîß Limpieza menor de duplicados en el dataclass Config.

Outputs se mantienen: KPIs + curvas + reports/allocator/weights_overlay.csv
"""

import argparse
import re
from pathlib import Path
from dataclasses import dataclass
import yaml
import pandas as pd
import numpy as np

# ---------- Utils ----------
def safe_corr(a, b, min_std=1e-12):
    a = pd.Series(a).astype(float).replace([np.inf,-np.inf], np.nan)
    b = pd.Series(b).astype(float).replace([np.inf,-np.inf], np.nan)
    m = a.notna() & b.notna()
    a, b = a[m], b[m]
    if len(a) < 3 or a.std() < min_std or b.std() < min_std:
        return float('nan')
    return float(a.corr(b))

def _ensure_utc_index(df: pd.DataFrame, ts_col: str = "timestamp") -> pd.DataFrame:
    if ts_col in df.columns:
        idx = pd.to_datetime(df[ts_col], utc=True)
        df = df.drop(columns=[ts_col])
        df.index = idx
    else:
        df.index = pd.to_datetime(df.index, utc=True)
    df = df[~df.index.duplicated(keep="last")].sort_index()
    return df

def _resample_4h(df: pd.DataFrame) -> pd.DataFrame:
    return df.resample("4h").last().ffill()

def ewm_std_series(series: pd.Series, span: int) -> pd.Series:
    return series.ewm(span=span, adjust=False).std()

def annualize_vol(x, bars_per_year: int = 6*365):
    fac = np.sqrt(bars_per_year)
    if isinstance(x, pd.Series):
        return x * fac
    try:
        return float(x) * fac
    except Exception:
        return float("nan")

def realized_vol_ann(r: pd.Series, span: int = 60, agg: str = "median") -> float:
    s = ewm_std_series(r.fillna(0.0), span=span).dropna()
    if not len(s):
        return float("nan")
    v = float({"last": s.iloc[-1], "mean": s.mean(), "median": s.median()}[agg])
    return float(annualize_vol(v))

def max_drawdown(r: pd.Series) -> float:
    eq = (1 + r.fillna(0)).cumprod()
    peak = eq.cummax()
    dd = eq/peak - 1.0
    return float(dd.min()) if len(dd) else float("nan")

def profit_factor(r: pd.Series) -> float:
    g = r[r>0].sum()
    l = -r[r<0].sum()
    if l <= 0:
        return float("inf") if g>0 else 0.0
    return float(g / l)

def sortino_ratio(r: pd.Series, bars_per_year: int = 6*365) -> float:
    mean = r.mean()
    downside = r[r<0].std(ddof=0)
    if downside == 0 or pd.isna(downside):
        return float("inf") if mean>0 else 0.0
    return float((mean * np.sqrt(bars_per_year)) / downside)

def kpis_table(r: pd.Series) -> dict:
    return dict(
        vol_ann = realized_vol_ann(r, span=60, agg="median"),
        mdd     = max_drawdown(r),
        pf      = profit_factor(r),
        wr      = float((r>0).mean()) if len(r) else float("nan"),
        sortino = sortino_ratio(r),
    )

def turnover_series(w_signed_df: pd.DataFrame) -> pd.Series:
    delta = w_signed_df.diff().abs()
    return delta.sum(axis=1).fillna(0.0)

# --- saneo y coerci√≥n num√©rica segura ---
NUM_COLS_D = ["w_diamante_raw","sD","retD_btc","close","price","ret","returns","r"]
NUM_COLS_P = ["w_perla_raw","sP","retP_btc","close","price","ret","returns","r"]
NUM_COLS_W = ["w_diamante","w_perla"]  # pesos de Coraz√≥n

def _sanitize_strings(df: pd.DataFrame) -> pd.DataFrame:
    if df is None:
        return df
    df = df.copy()
    df.replace({"nan": np.nan, "NaN": np.nan, "None": np.nan, "": np.nan}, inplace=True)
    return df

def _coerce_numeric_cols(df: pd.DataFrame, cols: list[str]) -> pd.DataFrame:
    if df is None:
        return df
    df = _sanitize_strings(df)
    for c in cols:
        if c in df.columns:
            df[c] = pd.to_numeric(df[c], errors="coerce")
    return df

def _as_float_series(s: pd.Series) -> pd.Series:
    return pd.to_numeric(s, errors="coerce").astype(float)

def _derive_returns(df: pd.DataFrame) -> pd.Series:
    # 1) si existe columna de retornos con varianza
    for cand in ["ret_btc","ret","returns","r","retD_btc","retP_btc"]:
        if cand in df.columns:
            s = pd.to_numeric(df[cand], errors="coerce").fillna(0.0)
            if s.std(skipna=True) > 0:
                return s
    # 2) derivar de precio si existe
    for px in ["close","price","px","Close"]:
        if px in df.columns:
            s = pd.to_numeric(df[px], errors="coerce").pct_change().fillna(0.0)
            if s.std(skipna=True) > 0:
                return s
    # 3) fallback: ceros
    return pd.Series(0.0, index=df.index)

def _series_or_constant(series: pd.Series | None, const_value: float, index: pd.Index) -> pd.Series:
    if series is None:
        return pd.Series(const_value, index=index)
    s = pd.to_numeric(series, errors="coerce")
    if float(s.fillna(0).abs().sum()) == 0.0:
        return pd.Series(const_value, index=index)
    return s

def _quantize(series: pd.Series, step: float) -> pd.Series:
    if step is None or step <= 0:
        return series
    return ((series / step).round() * step).clip(-10, 10)

_num_re = re.compile(r"[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?")
def _as_float(x, default: float) -> float:
    """Convierte valores tipo 0.60, '0.60‚Äì0.70', '0.6 to 0.7' al primer n√∫mero."""
    if isinstance(x, (int, float)) and np.isfinite(x):
        return float(x)
    if isinstance(x, str):
        m = _num_re.search(x.replace(",", "."))
        if m:
            try:
                return float(m.group(0))
            except Exception:
                pass
    return float(default)

# ---------- Config ----------
@dataclass
class Config:
    rebalance_freq: str
    timezone: str
    fee_bps: float
    slip_bps: float
    round_step: float
    max_delta_weight_bar: float
    alloc_base_d: float
    alloc_base_p: float
    vol_target_ann: float
    vol_clamp_min: float
    vol_clamp_max: float
    w_cap_total: float
    kill_mdd_30d: float
    cg_enabled: bool
    cg_lb: int
    cg_thr: float
    cg_max_pen: float
    cg_perf_days: int
    xi_cap: float
    files: dict
    outputs: dict
    # nuevos
    throttle_enabled: bool
    throttle_factor: float
    throttle_span_bars: int
    vol_ewm_span: int
    vol_floor_ann: float | None

def load_config(path: Path) -> Config:
    y = yaml.safe_load(path.read_text(encoding="utf-8")) or {}
    costs = y.get("costs", {}) or {}
    exec_ = y.get("exec", {}) or {}
    alloc = y.get("alloc_base", {}) or {}
    risk  = y.get("risk", {}) or {}
    vcl   = (risk.get("vol_clamp", {}) or {})
    kill  = (risk.get("kill_switch", {}) or {})
    # throttle puede venir en risk.throttle o al nivel ra√≠z
    thr   = (y.get("throttle", {}) or risk.get("throttle", {}) or {})
    vest  = (risk.get("vol_estimator", {}) or {})
    cg    = y.get("corr_gate", {}) or {}
    xi_s  = y.get("xi_star", {}) or {}

    return Config(
        rebalance_freq=y.get("rebalance_freq","4h"),
        timezone=y.get("timezone","UTC"),
        fee_bps=_as_float(costs.get("fee_bps",6), 6),
        slip_bps=_as_float(costs.get("slip_bps",6), 6),
        round_step=_as_float(exec_.get("round_step",0.0), 0.0),
        max_delta_weight_bar=_as_float(exec_.get("max_delta_weight_bar",0.20), 0.20),
        alloc_base_d=_as_float(alloc.get("diamante",0.50), 0.50),
        alloc_base_p=_as_float(alloc.get("perla",0.50), 0.50),
        vol_target_ann=_as_float(risk.get("vol_target_ann",0.20), 0.20),
        vol_clamp_min=_as_float(vcl.get("min",0.50), 0.50),
        vol_clamp_max=_as_float(vcl.get("max",1.20), 1.20),
        w_cap_total=_as_float(risk.get("w_cap_total",1.00), 1.00),
        kill_mdd_30d=_as_float(kill.get("mdd_30d",-0.10), -0.10),
        cg_enabled=bool(cg.get("enabled", False)),
        cg_lb=int(_as_float(cg.get("lookback_bars",60), 60)),
        cg_thr=_as_float(cg.get("threshold",0.35), 0.35),
        cg_max_pen=_as_float(cg.get("max_penalty",0.30), 0.30),
        cg_perf_days=int(_as_float(cg.get("perf_window_days",30), 30)),
        xi_cap=_as_float(xi_s.get("cap",1.70), 1.70),
        files=y.get("files", {}) or {},
        outputs=y.get("outputs", {}) or {},
        throttle_enabled=bool(thr.get("enabled", True)),
        throttle_factor=_as_float(thr.get("factor_when_neg", 0.65), 0.65),
        throttle_span_bars=int(_as_float(thr.get("span_bars", 36), 36)),
        vol_ewm_span=int(_as_float(vest.get("ewm_span", 60), 60)),
        vol_floor_ann=(float(str(vest.get("vol_floor_ann")).replace(",",".")) if vest.get("vol_floor_ann") is not None else None),
    )

def _must_read_series(path_str: str | None, label: str) -> pd.DataFrame:
    if not path_str:
        raise KeyError(f"[{label}] Ruta no especificada en 'files.{label}' del YAML.")
    p = Path(path_str)
    if not p.exists():
        raise FileNotFoundError(f"[{label}] Archivo no encontrado: {p}\n"
                                f"Sugerencia: ajusta 'files.{label}' en configs/allocator_sombra.yaml o coloca el archivo en la ruta esperada.")
    df = pd.read_csv(p)
    df = _ensure_utc_index(df)
    df = _resample_4h(df)
    return df

def read_xi_star(path: str, cap: float) -> float:
    try:
        val = float(Path(path).read_text(encoding="utf-8").strip())
        return min(max(val,1.0), cap)
    except Exception:
        return 1.0

# ---------- Core ----------
def simulate_overlay(cfg: Config) -> dict:
    # Inputs (con errores amigables)
    d  = _must_read_series(cfg.files.get("diamante"), "diamante")
    p  = _must_read_series(cfg.files.get("perla"),    "perla")
    w  = _must_read_series(cfg.files.get("heart_weights"), "heart_weights")
    lq = None
    if cfg.files.get("heart_lq") and Path(cfg.files.get("heart_lq")).exists():
        lq = _must_read_series(cfg.files.get("heart_lq"), "heart_lq")
    xi = read_xi_star(cfg.files.get("xi_star", "reports/heart/xi_star.txt"), cfg.xi_cap)

    # Forzar num√©rico
    d = _coerce_numeric_cols(d, NUM_COLS_D)
    p = _coerce_numeric_cols(p, NUM_COLS_P)
    w = _coerce_numeric_cols(w, NUM_COLS_W)

    # Alinear √≠ndices
    idx = d.index.union(p.index).union(w.index)
    if lq is not None:
        idx = idx.union(lq.index)
    idx = idx.sort_values()
    d = d.reindex(idx).ffill()
    p = p.reindex(idx).ffill()
    w = w.reindex(idx).ffill()
    if lq is not None:
        lq = lq.reindex(idx).ffill()

    # Pesos base
    wD_raw = d["w_diamante_raw"] if "w_diamante_raw" in d.columns else None
    wP_raw = p["w_perla_raw"]    if "w_perla_raw"   in p.columns else None
    wD_base = (_series_or_constant(wD_raw, 1.0, idx).clip(0,1) * float(cfg.alloc_base_d)).astype(float)
    wP_base = (_series_or_constant(wP_raw, 1.0, idx).clip(0,1) * float(cfg.alloc_base_p)).astype(float)

    # Pesos de Coraz√≥n
    wD_heart = _as_float_series(_series_or_constant(w.get("w_diamante"), 1.0, idx)).clip(0,1)
    wP_heart = _as_float_series(_series_or_constant(w.get("w_perla"),   1.0, idx)).clip(0,1)

    # Se√±ales firmadas
    sD = _as_float_series(_series_or_constant(d.get("sD"), 1.0, idx)).replace(0,1.0)
    sP = _as_float_series(_series_or_constant(p.get("sP"), 1.0, idx)).replace(0,1.0)

    # Retornos por barra (derivaci√≥n robusta)
    rD = _as_float_series(_derive_returns(d))
    rP = _as_float_series(_derive_returns(p))

    # AUTO-MUTE Perla si su retorno est√° plano
    dead_P = (rP.std(skipna=True) < 1e-10) or (float(rP.abs().sum()) == 0.0)
    if dead_P:
        wP_base = pd.Series(0.0, index=idx)
        wP_heart = pd.Series(0.0, index=idx)
        sP = pd.Series(0.0, index=idx)
        rP = pd.Series(0.0, index=idx)

    # Re-risk
    wD_rr = wD_base * wD_heart * xi
    wP_rr = wP_base * wP_heart * xi

    # Throttle ‚Äúprofit-aware‚Äù (NO look-ahead)
    contrib_t = (wD_rr * sD * rD) + (wP_rr * sP * rP)
    ema_perf  = contrib_t.shift(1).ewm(span=cfg.throttle_span_bars, adjust=False).mean()
    thr = pd.Series(1.0, index=ema_perf.index)
    if cfg.throttle_enabled:
        thr[ema_perf <= 0] = cfg.throttle_factor
    wD_rr = wD_rr * thr
    wP_rr = wP_rr * thr

    # Corr gate (opcional) ‚Äî sobre contribuciones
    penalty_applied, penalized_leg, corr_recent = 0.0, "none", float("nan")
    if cfg.cg_enabled:
        Nc = max(30, int(cfg.cg_lb))
        cD_tmp = (wD_rr * sD * rD).fillna(0.0)
        cP_tmp = (wP_rr * sP * rP).fillna(0.0)
        if len(cD_tmp.dropna()) >= Nc and len(cP_tmp.dropna()) >= Nc:
            corr_recent = cD_tmp.tail(Nc).corr(cP_tmp.tail(Nc))
            if pd.notna(corr_recent) and corr_recent > cfg.cg_thr:
                raw = (corr_recent - cfg.cg_thr) / (1.0 - cfg.cg_thr)
                pen = float(np.clip(raw, 0.0, cfg.cg_max_pen))
                Nb = max(6, int(cfg.cg_perf_days * 24 / 4))
                perfD = cD_tmp.tail(Nb).sum()
                perfP = cP_tmp.tail(Nb).sum()
                if perfD < perfP:
                    wD_rr = wD_rr * (1.0 - pen); penalized_leg = "Diamante"
                else:
                    wP_rr = wP_rr * (1.0 - pen); penalized_leg = "Perla"
                penalty_applied = pen

    # proxy sin look-ahead para el estimador de vol
    r_proxy_hist = ((wD_rr * sD * rD) + (wP_rr * sP * rP)).shift(1)

    # vol anualizada con EWM y PISO (si se especifica)
    vol_est_ann_series = annualize_vol(
        r_proxy_hist.ewm(span=cfg.vol_ewm_span, adjust=False).std()
    )
    if cfg.vol_floor_ann is not None:
        try:
            vol_est_ann_series = vol_est_ann_series.clip(lower=float(cfg.vol_floor_ann))
        except Exception:
            pass

    # scale (una sola vez, usando la vol efectiva)
    eff_vol = vol_est_ann_series.replace(0, np.nan)
    scale_series = (cfg.vol_target_ann / eff_vol) \
        .clip(cfg.vol_clamp_min, cfg.vol_clamp_max) \
        .fillna(1.0)

    # Aplicar scale
    wD_vol = wD_rr * scale_series
    wP_vol = wP_rr * scale_series

    # Cap total
    total = (wD_vol.abs() + wP_vol.abs())
    k = (cfg.w_cap_total / total.replace(0,np.nan)).clip(upper=1.0).fillna(1.0)
    wD_final = (wD_vol * k).fillna(0.0)
    wP_final = (wP_vol * k).fillna(0.0)

    # Suavizado + cuantizaci√≥n
    def smooth(series, max_delta):
        out, last = [], 0.0
        for v in series.fillna(0.0).values:
            delta = np.clip(v - last, -max_delta, +max_delta)
            last = last + delta
            out.append(last)
        return pd.Series(out, index=series.index)

    wD_sm = _quantize(smooth(wD_final, cfg.max_delta_weight_bar), cfg.round_step)
    wP_sm = _quantize(smooth(wP_final, cfg.max_delta_weight_bar), cfg.round_step)

    # Exposiciones firmadas
    eD_base = (wD_base * sD).fillna(0.0)
    eP_base = (wP_base * sP).fillna(0.0)
    eD_ovly = (wD_sm   * sD).fillna(0.0)
    eP_ovly = (wP_sm   * sP).fillna(0.0)

    # Turnover y costes
    to_base = turnover_series(pd.DataFrame({"D": eD_base, "P": eP_base}))
    to_ovly = turnover_series(pd.DataFrame({"D": eD_ovly, "P": eP_ovly}))
    bps = (cfg.fee_bps + cfg.slip_bps) / 1e4
    cost_base = to_base * bps
    cost_ovly = to_ovly * bps

    # Retornos cartera
    r_base  = (eD_base * rD) + (eP_base * rP) - cost_base
    r_ovly  = (eD_ovly * rD) + (eP_ovly * rP) - cost_ovly

    # Diagn√≥stico extra
    scale_at_max = (scale_series >= (cfg.vol_clamp_max - 1e-12)).mean()
    cap_binding  = ((wD_vol.abs() + wP_vol.abs()) > (cfg.w_cap_total - 1e-12)).mean()

    out = {
        "r_base": r_base.fillna(0.0),
        "r_overlay": r_ovly.fillna(0.0),
        "e_base": pd.DataFrame({"D": eD_base, "P": eP_base}),
        "e_overlay": pd.DataFrame({"D": eD_ovly, "P": eP_ovly}),
        "retD": rD, "retP": rP,
        "lq": lq["lq_flag"].astype(str) if (lq is not None and "lq_flag" in lq.columns) else None,
        "diag": {
            "corr_recent": float(corr_recent) if pd.notna(corr_recent) else float("nan"),
            "corr_penalty": float(penalty_applied),
            "corr_penalized_leg": penalized_leg,
            "scale_at_max_frac": float(scale_at_max),
            "cap_binding_frac": float(cap_binding),
        },
        "weights_overlay": pd.DataFrame({
            "wD": wD_sm, "wP": wP_sm,
            "eD": eD_ovly, "eP": eP_ovly,
            "scale": scale_series, "cap_k": k,
            "vol_est_ann": vol_est_ann_series,
        })
    }
    return out

def write_outputs(sim: dict, cfg: Config):
    out_dir = Path(cfg.outputs.get("equity_dir","reports/allocator/curvas_equity/"))
    out_dir.mkdir(parents=True, exist_ok=True)
    eq_base = (1 + sim["r_base"]).cumprod()
    eq_ovly = (1 + sim["r_overlay"]).cumprod()
    eq_base.to_frame("equity_base").to_csv(out_dir/"eq_base.csv", date_format="%Y-%m-%d %H:%M:%S%z")
    eq_ovly.to_frame("equity_overlay").to_csv(out_dir/"eq_overlay.csv", date_format="%Y-%m-%d %H:%M:%S%z")

    # pesos/diagn√≥stico
    w_out = Path(cfg.outputs.get("weights_overlay","reports/allocator/weights_overlay.csv"))
    w_out.parent.mkdir(parents=True, exist_ok=True)
    sim["weights_overlay"].to_csv(w_out, date_format="%Y-%m-%d %H:%M:%S%z")

    # KPIs
    k_base = kpis_table(sim["r_base"])
    k_ovly = kpis_table(sim["r_overlay"])

    to_base_total = float(turnover_series(sim["e_base"]).sum())
    to_ovly_total = float(turnover_series(sim["e_overlay"]).sum())

    def safe_ratio_num(a, b):
        if pd.notna(a) and pd.notna(b) and b != 0:
            return (a - b) / abs(b)
        return float("nan")

    d_turnover = safe_ratio_num(to_ovly_total, to_base_total)
    if not np.isfinite(d_turnover):
        d_turnover_str = f"(base={to_base_total:.4f}, overlay={to_ovly_total:.4f})"
    else:
        d_turnover_str = f"{d_turnover:.2%}"

    target = cfg.vol_target_ann
    vol_err  = (abs(k_ovly["vol_ann"] - target)/target) if (pd.notna(k_ovly["vol_ann"]) and target>0) else float("nan")
    mdd_impr = (1 - (abs(k_ovly["mdd"])/abs(k_base["mdd"]))) if (pd.notna(k_ovly["mdd"]) and pd.notna(k_base["mdd"]) and k_base["mdd"]!=0) else float("nan")

    # corr por contribuci√≥n (overlay)
    cD = (sim["e_overlay"]["D"] * sim["retD"]).fillna(0.0)
    cP = (sim["e_overlay"]["P"] * sim["retP"]).fillna(0.0)
    corr_dp = safe_corr(cD, cP)

    lq_line = ""
    if sim.get("lq") is not None:
        hr = (sim["lq"] == "HIGH_RISK").mean()
        lq_line = f"- **%HIGH_RISK (LQ)**: {hr:.2%}\n"

    kpis_md = Path(cfg.outputs.get("kpis","reports/allocator/sombra_kpis.md"))
    kpis_md.parent.mkdir(parents=True, exist_ok=True)
    with kpis_md.open("w", encoding="utf-8") as f:
        f.write("# KPIs ‚Äî Allocator (modo sombra)\n\n")
        f.write("| Serie | Vol anual | MDD | PF | WR | Sortino |\n|---|---:|---:|---:|---:|---:|\n")
        f.write(f"| Base | {k_base['vol_ann']:.4f} | {k_base['mdd']:.2%} | {k_base['pf']:.2f} | {k_base['wr']:.2%} | {k_base['sortino']:.2f} |\n")
        f.write(f"| Overlay | {k_ovly['vol_ann']:.4f} | {k_ovly['mdd']:.2%} | {k_ovly['pf']:.2f} | {k_ovly['wr']:.2%} | {k_ovly['sortino']:.2f} |\n\n")
        f.write("## Diferenciales/claves\n")
        f.write(f"- **Error de vol objetivo (overlay)**: {vol_err:.2%}\n")
        f.write(f"- **Mejora de MDD**: {mdd_impr:.2%}\n")
        f.write(f"- **ŒîPF (overlay vs base)**: {safe_ratio_num(k_ovly['pf'], k_base['pf']):.2%}\n")
        f.write(f"- **ŒîTurnover (overlay vs base)**: {d_turnover_str}\n")
        f.write(f"- **corr(D,P)**: {corr_dp:.2f}\n")
        f.write(lq_line)
        diag = sim.get("diag", {})
        f.write(f"- **corr(D,P) (reciente)**: {diag.get('corr_recent', float('nan')):.2f}\n")
        f.write(f"- **Penalizaci√≥n por correlaci√≥n**: {diag.get('corr_penalty', 0.0):.2%} sobre {diag.get('corr_penalized_leg', 'none')}\n")
        f.write(f"- **Escala pegada al m√°x**: {diag.get('scale_at_max_frac', 0.0):.2%} de barras\n")
        f.write(f"- **Cap total binding**: {diag.get('cap_binding_frac', 0.0):.2%} de barras\n")
    return kpis_md, out_dir/"eq_base.csv", out_dir/"eq_overlay.csv"

def main():
    ap = argparse.ArgumentParser(description="Allocator sombra mini-runner")
    ap.add_argument("--config", type=str, default="configs/allocator_sombra.yaml")
    args = ap.parse_args()
    cfg = load_config(Path(args.config))
    sim = simulate_overlay(cfg)
    kpis_md, eq_b, eq_o = write_outputs(sim, cfg)
    print("[OK] KPIs:", kpis_md)
    print("[OK] Curvas:", eq_b, eq_o)
    if "weights_overlay" in sim:
        w_out = Path(cfg.outputs.get("weights_overlay","reports/allocator/weights_overlay.csv"))
        print("[OK] Weights overlay:", w_out)

    # --- Diagn√≥stico NET por pierna (run actual, sin staleness) ---
    cD_now = (sim["e_overlay"]["D"] * sim["retD"]).fillna(0.0)
    cP_now = (sim["e_overlay"]["P"] * sim["retP"]).fillna(0.0)
    netD = float((1 + cD_now).prod() - 1)
    netP = float((1 + cP_now).prod() - 1)
    print(f"NET D ovl: {netD} | NET P ovl: {netP}")

if __name__ == "__main__":
    main()
